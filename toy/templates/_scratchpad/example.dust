{>list-tile /}
{>"templates/components/list-tile" /}

{!
  Same as {>list-tile /} but *no* context is passed in by default.
!}
{$list-tile /}

{!
  Context is passed in only through params, which are never overridden by
  existing context. Here, list-tile.dust always receives foo as "foo".
!}
{$list-tile foo="foo" /}

{!
  Before being passed, params are resolved with full access to outer context.
!}
{$list-tile foo=context.anything /}

{!
  Body content is compiled and passed in as a special `body` param, which is
  reserved.
!}
{$list-tile foo="foo"}
  <em>{bar}</em> {! ← `body` inside list-tile.dust !}
{/list-tile}

{! Additional bodies are passed in as named props on `body`. !}
{$list-tile foo="foo"}
  <em>{bar}</em>
{:baz}
  <strong>{baz}</strong> {! ← body.baz inside list-tile.dust !}
{/list-tile}

{!
  All of the above examples are actually autoloading list-tile.dust from a
  source directory configurable as some kind of env variable. Source directories
  should support globbing.

  If loading from somewhere unusual, you should be able to pass the template
  file path (which should resolve the same as for normal partials). In this
  case the initial identifier does nothing but give you something to close the
  tag with.
!}
{$list-tile "some-other-dir/list-tile" foo="foo"}
  <em>{bar}</em>
{:bazBody}
  <strong>{baz}</strong>
{/list-tile}

{!
  Autoload and compile component-name.dust as a partial from a configurable
  directory (possibly with recursive search). Explicit pathing could be done
  like this: {$component-name "some/dir/component-name" foo="foo" /}
!}
{$component-name foo="foo"}
  <em>{bar}</em> {! ← {body} inside list-tile.dust !}
{:baz}
  {$other-component bar=someContext.quux /} {! ← {body.baz} inside list-tile.dust !}
{/component-name}

